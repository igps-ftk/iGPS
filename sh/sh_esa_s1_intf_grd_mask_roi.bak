#!/bin/sh

# Name:
#   sh_esa_s1_intf_grd_cut_roi
#   

# Purpose:
#   

# Example:
#   

# Modifications:
#   

# Algorigthm:
#   

# Dependency:
#   trans.dat
#   intf_all/
#
path=./intf_all_x2/
opath=./intf_all_x2_mask/

PROG=sh_esa_s1_intf_grd_mask_roi


file_mask=_out_mask.grd
roi_file=

types='corr_cut.grd unwrap_mask.grd'

if [ $# -eq 0 ]; then
    echo "[$PROG]ERROR: please give input parameters!!"
    echo "[$PROG]Usage: sh_esa_s1_intf_grd_cut_roi -file ROI.kml"
    exit 1
fi


while [ "$1" != "" ]; do
    case $1 in
	-file)
	    roi_file=$2
	    ;;
        -path)
            path=$2
            ;;
        -opath)
            opath=$2
            ;;
	*)
	    echo "[$PROG]ERROR: invalid option ($1)!!"
	    exit 1
	    ;;
	esac
    shift 2
done

echo $roi_file
echo $path 
echo $opath

if [ ! -d $opath ]; then
  echo "[]INFO: mkdir -p $opath"
  mkdir -p $opath
fi


intfs=`find $path -maxdepth 1 -type d -name "20?????_20?????"|sort`
for intf in $intfs; do
  echo intf $intf
  ointf="${opath}/`basename $intf`"
  echo ointf $ointf
  if [ ! -d $ointf ]; then
    #echo "[]INFO: mkdir -p $ointf"
    mkdir -p $ointf
  fi
  
  file_corr="${intf}/corr_cut.grd"
  file_unwrap="${intf}/unwrap_mask.grd"
  if [ ! -s $file_corr ]; then
    echo "[]WARNING: not corr_cut.grd file exist for $intf!"
    continue
  fi
  if [ ! -s $file_unwrap ]; then
    echo "[]WARNING: not unwrap_mask.grd file exist for $intf!"
    continue
  fi
  
  echo file_corr $file_corr
  #exit
  
  if [ ! -s $file_mask ]; then
    ln -s ./topo/trans.dat .
    I=`gmt grdinfo -I ${file_corr}`
    echo I $I
    echo "[$PROG]INFO: create the mask from KML polygon file"
    gmt kml2gmt $roi_file | grep -v '>' | awk '{print $1,$2,0}' > _out_mask.llh 
    cat _out_mask.llh
    echo "proj_ll2ra_ascii.csh trans.dat _out_mask.llh _out_mask.xyz"
    proj_ll2ra_ascii.csh trans.dat _out_mask.llh _out_mask.xyz
    cat _out_mask.xyz | awk '{print $1,$2}' > _out_mask.ra
    cat _out_mask.ra
    #R=`gmt gmtinfo $I _out_mask.psxy`
    #R=-R${xmin}/${xmax}/${ymin}/${ymax}
    R=`gmt grdinfo $I ${file_corr}`
    echo R $R
    echo $file_corr
    #exit
    echo "[]INFO:creating mask file ..."
    gmt grdmask _out_mask.ra -R${file_corr} $I -N1/1/NaN -G_out_mask.grd
    #echo "[]INFO: converting zero to NaN ..."
    #gmt grdmath _out_mask1.grd 0 NAN = _out_mask.grd
    #the inverse ( gmt grdmath grid.grd 0 AND = NaNtoZero.grd)??
    gmt makecpt -Cjet -I -Z -T0/1/1  > mask.cpt

    gmt grdimage _out_mask.grd -JX6.5i -Bxaf+lRange -Byaf+lAzimuth -BWSen -Cvel.cpt -X1.3i -Y3i -P -K > _out_mask.ps
    gmt psscale -R_out_mask.grd -J -DJTC+w5i/0.2i+h+e -Cvel.cpt -Bxaf+l"Unwrapped phase" -By+lrad -O >> _out_mask.ps
    gmt psconvert -A -Tj -P -Z _out_mask.ps
    
    proj_ra2ll.csh trans.dat _out_mask.grd _out_mask_ll.grd
    #grd2kml.csh _out_mask_ll mask.cpt
    sh_grd2kml  _out_mask_ll mask.cpt
 
    gmt grdinfo -C ${file_corr}
    gmt grdinfo -C _out_mask.grd
  fi
  
  
  ofile_corr="${ointf}/corr_cut.grd"
  ofile_unwrap="${ointf}/unwrap_mask.grd"
  
  if [ ! -s $ofile_corr ]; then
    echo "gmt grdmath ${file_corr} _out_mask.grd MUL = ${ofile_corr}"
    echo "gmt grdmath ${file_corr} _out_mask.grd MUL = ${ofile_corr}" | sh
    #exit
  fi
  
  if [ ! -s $ofile_unwrap ]; then
    echo "gmt grdmath ${file_unwrap} _out_mask.grd MUL = ${ofile_unwrap}"
    echo "gmt grdmath ${file_unwrap} _out_mask.grd MUL = ${ofile_unwrap}" | sh
    #exit
  fi
  
  
done

exit

files=`find ${path} -name "corr_cut.grd"`

file=`echo $files | awk '{print $1}'`
pI=`grdinfo -I $file`
echo $pI
pR=`gmt gmtinfo $pI .roi.xyz`
echo $pR
#exit

for file in $files; do
    path_in=`dirname $file`
    path_out="${opath}/`basename $path_in`"
    mkdir -p $path_out
    
    #if [ ! -s $path_out/unwrap_mask_ll.png ]; then
    # 	\cp -r $path_in/unwrap_mask_ll.png $path_out
    #fi

    for type in $types; do
	
	file_in=${path_in}/${type}
	file_out=${path_out}/${type}

	if [ -s $file_out ]; then
	    echo "[]Exist! Skipped."
	    continue
	fi

	echo grdcut $file_in $pR -G${file_out}
	echo grdcut $file_in $pR -G${file_out} | sh
    done

    exit
done

#while read line; do
#    echo $line
#done < .tmp2
