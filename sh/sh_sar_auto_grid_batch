#!/bin/sh

# Name:
#   sh_sar_auto_grid_batch
#

# Purpose:
#

# Example:
#

# Modifications:
#

# Algorigthm:
#

# Dependency:
#

. ${HOME}/.bashrc


PROG=sh_sar_auto_grid_batch


usage(){
    echo "[$PROG]INFO: $PROG [-file session_list_file ]"
    echo "[$PROG]INFO:       [-iw SUBSWATH]"
    echo "[$PROG]INFO:       [-proc_type TYPE]"
    echo "[$PROG]INFO:       [-stage n]"
    echo "[$PROG]INFO:       [-t1_intf YYYYMMDD ][ -t2_intf YYYYMMDD]"
    echo "[$PROG]INFO:       [-t1_list YYYYMMDD ][ -t2_list YYYYMMDD]"
    echo "[$PROG]INFO:       [-t1_sbas YYYYMMDD ][ -t2_sbas YYYYMMDD]"

    echo "[$PROG]INFO: "
    echo "[$PROG]INFO:   Subswaths:"
    echo "[$PROG]INFO:     iw1 - subswath 1 (F1)"
    echo "[$PROG]INFO:     iw2 - subswath 2 (F2)"
    echo "[$PROG]INFO:     iw3 - subswath 3 (F3)"
    echo "[$PROG]INFO:    Can be any combination of the three, e.g., iw1,iw3"
    echo "[$PROG]INFO: "
    echo "[$PROG]INFO:   processing types:"
    echo "[$PROG]INFO:     full         -  4:1 multilook ( 25 m)"
    echo "[$PROG]INFO:     normal       -  8:2 multilook ( 50 m)"
    echo "[$PROG]INFO:     interseismic - 16:4 multilook (100 m)"
    echo "[$PROG]INFO: "
    echo "[$PROG]INFO:   stage:"
    echo "[$PROG]INFO:     0 - create dem"
    echo "[$PROG]INFO:     1 - cut/merge tiff files (default)"
    echo "[$PROG]INFO:     2 - alignment"
    echo "[$PROG]INFO:     3 - dem2topo_ra"
    echo "[$PROG]INFO:     4 - intf_tops"
    echo "[$PROG]INFO:     5 - sbas"
    echo "[$PROG]INFO:     6 - update align"
    echo "[$PROG]INFO:     7 - downsample interferograms"
    echo "[$PROG]INFO:     8 - "
    echo "[$PROG]INFO:     9 - "
    echo "[$PROG]INFO:     10 - "
    echo "[$PROG]INFO:     11 - create intf.in"
    echo "[$PROG]INFO:     12 - clean slurm temporary files"
    echo "[$PROG]INFO:     13 - unzip S1 SLC files to temporary directory"
    echo "[$PROG]INFO:     14 - clear uncompressed temporary S1 data"
    echo "[$PROG]INFO:     15 - create input.lst* files"
    echo "[$PROG]INFO:     16 - clean update_align temporary files"
    echo "[$PROG]INFO:     17 - clean unnecessary files in intf_all"
    echo "[$PROG]INFO:     18 - restore to init state"
    echo "[$PROG]INFO:     19 - delete high-resolution displacement files in sbas"




    echo "[$PROG]INFO: "
}




host=`hostname`

session_stage=-1
sess_stages=-1
#locking files
# 0 - dem
# 1 - tiff cut/merge
# 2 - align
# 3 - dem2topo_ra
# 4 - intf
# 5 - sbas
#
# 6 - update align
# 7 - downsample interferograms (intf_all)
#
## 9 - all <=5 levels

proc_type=normal
sess_type=init #init/proc

delay=10 #time of delay for paralleling tasks (only forming interferograms), default 20 seconds

is_update_list=n
path_slc=/sar/s1
path=/sar/proc_gmtsar/auto_grid
#cd $path

file_proc=proc.list
file_proc=

iws='iw1 iw2 iw3'

t1_sbas=1
t2_sbas=120
t2_sbas=72
t2_sbas=

t1_intf=1
t2_intf=72

t1_list=19800101
t2_list=20991231

is_clear_lock=n
expts=

n_intf_sbas_skip=0


while [ "$1" != "" ]; do
  case $1 in
   -delay)
      delay=$2
      ;;
    -e|-expt)
      expts=$2
      ;;
    -file)
      file_proc=$2
      ;;
    -force)
      is_clear_lock=$2
      ;;
    -iw)
      iws=$2
      iws=`echo $iws | sed -e 's/,/ /g'`
      ;;
    -sbas_skip_intf)
      n_intf_sbas_skip=$2
      ;;
    -proc_type)
      proc_type=$2
      ;;
    -sess_type)
      sess_type=$2
      ;;
    -stage)
      session_stage=$2
      ;;
    -stages)
      sess_stages=$2
      ;;
    -t1_intf)
      t1_intf=$2
      ;;
    -t2_intf)
      t2_intf=$2
      ;;
    -t1_list)
      t1_list=$2
      ;;
    -t2_list)
      t2_list=$2
      ;;
    -t1_sbas)
      t1_sbas=$2
      ;;
    -t2_sbas)
      t2_sbas=$2
      ;;
    -update_list)
      is_update_list=$2
      ;;
    -h|-H|--help|-help|"?")
      usage
      exit 0
      ;;
    *)
      echo "[$PROG]ERROR: invalid option ($1)!!"
      echo "[$PROG]INFO: use $PROG -h for usage."
      exit 1
      ;;
  esac

  shift 2
done

file_in=input.lst.init.2020
file_in=input.lst.init
file_in="input.lst.${sess_type}"

if [ $session_stage -le -1  -o $session_stage -gt 19 ] && [ $sess_stages -le -1  -o $sess_stages -gt 19 ]; then
  echo "[]ERROR: processing stage not specified or wrong value!!"
  echo "[]INFO: -stage $session_stage   -stages $sess_stages  (both default -1)"
  echo "{}INFO: see more info in help (-h)"
  exit 1
fi


if [ $sess_stages -ne -1 ]; then
  if [ $session_stage -eq -1 ]; then #if no stage given
    if [ $sess_stages -gt 5 ]; then
      session_stage=$sess_stages
    else
      session_stage=`echo $sess_stages | awk '{for(i=0;i<=n;i++){print i}}' n=$sess_stages`
    fi
  else
    echo "[]WARNING: both -stage and -stages were given! ONLY -stage information used."
  fi
fi

echo session_stage $session_stage
echo sess_stages $sess_stages
#is_in=`echo 1 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
#echo is_in $is_in
#if [[ "$is_in" == "1" ]]; then
#  echo stage 1
#fi
#is_in=`echo 11 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
#echo is_in $is_in
#if [[ "$is_in" == "1" ]]; then
#  echo stage 11
#fi


#exit

iw_ids=`echo $iws | sed -e 's/iw/ /g'`
#e.g., iw_ids='1 2 3'

#checkcing processing types: interseismic, normal, full, ...
if [ ! -s ${esa_data}/config/batch_tops.config.${proc_type} ]; then  
  echo "[$PROG]ERROR: invalid prcessing type ($proc_type)!!"
  tmps=`ls ${esa_data}/config/batch_tops.config.*`
  types=
  for tmp in $tmps; do
    type=`basename $tmp | awk -F. '{print $3}'`
    types="$types $type"
  done
  echo "[]INFO: valid processing types are: $types"
  exit 1
fi

#echo session_stage is $session_stage
session_stage_id=`echo $session_stage | awk '{print $NF}'`
case $session_stage_id in
  0)
    stage_name='create_dem'
    ;;
  1)
    stage_name='tiff_cut_merge'
    ;;
  2)
    stage_name='alignment'
    ;;
  3)
    stage_name='dem2topo_ra'
    echo stage_name $stage_name
    ;;
  4)
    stage_name='intf'
    ;;
  5)
    stage_name='sbas'
    ;;
  6)
    stage_name='update_align'
    ;;
  7)
    stage_name='downsample_interferogram'
    ;;
  11)
    stage_name='create_intf_in'
    ;;
  12)
    stage_name='clean_temporary'
    ;;
  13)
    stage_name='unzip_slc'
    ;;
  14)
    stage_name='clean_unzip_slc'
    ;;
  15)
    stage_name='create_input_lst'
    ;;
  16)
    stage_name='clean_update_align_temporary'
    ;;
  17)
    stage_name='clean_intf_all'
    ;;
  18)
    stage_name='restore_to_init'
    ;;
  19)
    stage_name='del_sbas_disp'
    ;;
  *)
    usage
    echo "[]ERROR: invalid stage ($session_stage_id)!!"
    exit 1
    ;;
esac

file_lock="${session_stage_id}.${stage_name}.${host}.lock"
echo file_lock $file_lock
file_log="_tmp.${session_stage_id}.${stage_name}.${host}.log.`date +%DT%T | sed -e 's/\//-/g' | sed -e 's/:/_/g'`.txt"
echo file_log $file_log
#exit

oldpath=`pwd`


if [ "$expts" == "" ];then
  # if [ "$file_proc" != "" && -s $file_proc ]; then
  if [ "$file_proc" != "" ]; then
    expts=`grep '^ ' $file_proc`
    np=`grep '^ ' $file_proc | wc -l`
  else
    echo "[]INFO: no expt list/file given. Use current directory."
    expt=`basename $oldpath`
    tmp=`echo $expt | grep '^[AD]..._....'`
    echo $tmp $expt
    if [ "$tmp" == "" ]; then
      echo "[$PROG]ERROR: no expt in current location!!"
      exit 1
    fi
    echo "[]INFO:processing current directory ($expt) ..."
    expts=$expt
    np=1
  fi
else
  expts=`echo $expts | sed -e 's/,/ /g'`
  np=`echo $expts | awk '{print NF}'`
fi
echo "# expt: $np $expts"
#exit

pi=0
for expt in $expts; do
  echo processing $expt
  cd $oldpath
  pwd

  opath=${path}/$expt

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>15>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>15. create input.lst* files (input.lst input.lst.ok input.lst.init input.lst.proc)
    is_in=`echo 15 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      echo sh_sar_auto_grid_create_input_list -expt $expt -t1 $t1_list -t2 $t2_list
      echo sh_sar_auto_grid_create_input_list -expt $expt -t1 $t1_list -t2 $t2_list | sh >> $file_log
      #exit
    fi
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<15<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  
  if [ ! -d $opath ]; then
    echo "[]ERROR: not exist ($opath)!!"
    continue
  fi
  cd $opath
  pwd
  #exit
  

  #>>
  if [ 0 ] ;then #for debug pupose only
    file_in2=input.lst.init
    if [ ! -s $file_in2 ]; then
      file_in2=`ls over*.txt`
    fi
    #echo input file is $file_in2
    #tmp=`grep '^ ' $file_in2 | grep '_2020'`
    #if [ "$tmp" == "" ]; then
    #  echo "[]WARNING: no data for year 2020 ($expt)!"
    #  continue
    #fi
    #grep '^ ' $file_in2 | grep '_2020'  > $file_in
  fi
  #<<

  wc -l $file_in

  if [ ! -s $file_in ]; then
    echo "[$PROG]WARNING: no data file ($file_in) for expt ($expt)!"
    continue
  fi



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>14>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>14. clear uncompressed temporary S1 data   
    is_in=`echo 14 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -s $file_in ]; then
        continue
      fi
      
      #  
      echo "[$PROG]INFO: clean temporary uncompressed observation files ..."
      echo sh_esa_s1_unzip_clean $file_in
      echo sh_esa_s1_unzip_clean $file_in | sh

      pwd
    fi

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<14<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




#------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 0>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  #>>>SESSION_STAGE_0
  if [ $session_stage_id -lt 0 ]; then
    exit
  fi
  
  #processing step 0: create dem.grd
  path_cur=`pwd`
  sess=`basename $path_cur`
  pwd
  #exit

  ##if [[ "${session_stage[@]}" =~ "0" ]]; then
  is_in=`echo 0 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
  if [[ "$is_in" == "1" ]]; then

  #remove broken symbolic link to dem.grd
  if [[ -L "dem.grd" ]] && [[ ! -a "dem.grd" ]];then
    echo "[]INFO: broken link to dem.grd"
    file dem.grd
    echo "remove it ..."
    \rm -rf dem.grd
  fi
  #create/link dem.grd file
  if [ ! -s ./dem.grd ] ; then
      path_dem=${esa_data}/topo/srtm3/${sess}
      if [ -s ${path_dem}/dem.grd ]; then
       echo "[$PROG]INFO: ln -s ${path_dem}/dem.grd $path_cur"
       echo ln -s ${path_dem}/dem.grd $path_cur | sh
      else
          mkdir -p ${path_dem}/
          files_kml=`find $path_cur -maxdepth 1 -name "*.kml"`
          if [ "$files_kml" = "" ]; then
              echo "[$PROG]ERROR: DEM file ./dem.grd is mondatory !! Stages >=0 skipped."
              continue
          fi
          echo "[$PROG]WARNING: DEM file ./dem.grd is mondatory and missing!"
          echo "[$PROG]INFO: creating dem.grd file from KML files if available"
          cd $path_dem
          \rm -f .tmp.kml
          for file_kml in $files_kml; do
              gmt kml2gmt $file_kml >> .tmp.kml
          done
          xmin=`gmt gmtinfo -C .tmp.kml | awk '{print $1-.3}'`
          xmax=`gmt gmtinfo -C .tmp.kml | awk '{print $2+.3}'`
          ymin=`gmt gmtinfo -C .tmp.kml | awk '{print $3-.3}'`
          ymax=`gmt gmtinfo -C .tmp.kml | awk '{print $4+.3}'`
          echo "[$PROG]INFO: geographical ranges $xmin $xmax $ymin $ymax "
          echo "gmt grdcut ${esa_data}/topo/srtm3/grid/china.grd -Gdem.grd -R${xmin}/${xmax}/${ymin}/${ymax}"
          gmt grdcut ${esa_data}/topo/srtm3/grid/china.grd -Gdem.grd -R${xmin}/${xmax}/${ymin}/${ymax}
          zmin=`gmt grdinfo -C dem.grd | awk '{print $6}'`
          zmax=`gmt grdinfo -C dem.grd | awk '{print $7}'`
          echo "[$PROG]INFO: topo range zmin zmax $zmin $zmax"
          gmt makecpt -Cjet -T$zmin/$zmax/1 -Z -I > dem.cpt
          grd2kml.csh dem ./dem.cpt
          ln -s ${path_dem}/dem.grd $path_cur
          cd $path_cur
      fi
  fi
  file dem.grd
  pwd
  fi
  #exit 
  #<<<SESSION_STAGE_0
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 1>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  if [ $session_stage_id -lt 1 ]; then
    continue
  fi
  
  #loop for each subswath (iw1 iw2 iw3)
  for i in $iw_ids ; do
    pwd
    echo "[$PROG]INFO: processing F${i}"

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>16>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>16. clean update_align temporary files
    is_in=`echo 16 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi

      pwd
      echo "\rm -rf F${i}/_align_group_node*"
      \rm -rf F${i}/_align_group_node*

      #exit 1
    fi
    #<<<16
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<16<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>17>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>17. clean unnecessary files in intf_all (only leave files for sbas)
    is_in=`echo 17 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi

      pwd
      if [ -d F${i}/intf_all ]; then
       
        echo "sh_sar_clean_intf_all_all -path F${i}/intf_all"
        echo "sh_sar_clean_intf_all_all -path F${i}/intf_all" | sh


        #exit 1
      fi
    fi
    #<<<17
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<17<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>18>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>18. restore to init state (delete intf_all* and additional SLC files)
    is_in=`echo 18 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        echo "[]WARNING: $expt/F${i} not exist!"
        continue
      fi

      pwd
      
      expt_status_code=`sh_sar_auto_grid_check_status -expt $expt -iw iw${i} | tail -1 | awk '{print $3}'`
      echo status code $expt_status_code
      if [ $expt_status_code -lt 6 ]; then
        echo "[]WARNING: sbas sessions not finished! Run the below command to manually do it."
        echo "sh_sar_auto_grid_restore_to_init -expt $expt -del_slc y -iw iw${i}"
        continue
      fi
      
      echo "sh_sar_auto_grid_restore_to_init -expt $expt -del_slc y -iw iw${i} "
      echo "sh_sar_auto_grid_restore_to_init -expt $expt -del_slc y -iw iw${i}" | sh
    fi
    #<<<18
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<18<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>19>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>19. delete high-resolution displacement files in sbas 
    is_in=`echo 19 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        echo "[]WARNING: $expt/F${i} not exist!"
        continue
      fi

      pwd

      expt_status_code=`sh_sar_auto_grid_check_status -expt $expt -iw iw${i} | tail -1 | awk '{print $3}'`
      echo status code $expt_status_code
      if [ $expt_status_code -lt 6 ]; then
        echo "[]WARNING: sbas sessions not finished!"
        continue
      fi

      echo "\rm -f F${i}/sbas*/disp*"
      \rm -f F${i}/sbas*/disp*
    fi
    #<<<19
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<19<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



    #tmp=`ls F${i}/*.lock`
    tmp=`find ./F${i}/ -maxdepth 1 -name  "*.lock"`
    if [ "$tmp" != "" ]; then   # if locked by any stage, then skip the following
      echo "[$PROG]WARNING: session in `pwd`/F${i} has been locked!! Stages >=1 skipped."
      echo "$tmp"
      #is_clear_lock=n
      if [ "$is_clear_lock" == "y" ]; then
        for tmp1 in $tmp; do
          echo "clearing locking $tmp1"
          \rm -f $tmp1
        done
      else
        continue
      fi
    fi



    #stage 1. tiff cut/merge
    #>>>(1)    
    #uncompress files
    #echo  sh_esa_s1_unzip_node $file_in iw${i} | sh
    #if [[ "${session_stage[@]}" =~ "1" ]]; then
    is_in=`echo 1 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then


    if [ -d F${i} -a -s F${i}/baseline_table.dat ]; then
      echo "[$PROG]WARNING: processing directory F${i} already exist and processed! Stage 1 skipped."
    else
      mkdir -p F${i}
      cd F${i}
  
      date > $file_lock
      
      mkdir -p topo
      cd topo
      if [ ! -s dem.grd ]; then
          \rm -f dem.grd >& /dev/null
          ln -s ../../dem.grd ./ 
      fi
      cd ..
  
  
      echo sh_esa_s1_run_tsa -file ../$file_in -iw iw${i} -skip_align y -proc_type normal
      echo sh_esa_s1_run_tsa -file ../$file_in -iw iw${i} -skip_align y -proc_type normal | sh
  
      \rm -rf $file_lock
      cd .. #return from F?
    fi
    fi
    #<<<(1)
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 1<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    #exit



#------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    if [ $session_stage_id -lt 2 ]; then
      continue
    fi
    #stage 2. alignment
    #>>>(2)
    #if [[ "${session_stage[@]}" =~ "2" ]]; then
    is_in=`echo 2 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then


    #check whether previous work has been done
    if [ ! -d F${i} ]; then
      echo "[$PROG]WARNING: processing directory F${i} NOT exist! Stages >=2 skipped."
      continue
    fi
    #continue
    if [ ! -s F${i}/data.in ]; then
      echo "[$PROG]WARNING: no data.in for expt ($expt F${i})! Stages >=2 skipped."
      continue
    fi
    #
    tmp=`head -1 F${i}/baseline_table.dat | awk '{print substr($1,1,2)}'`
    nb=`cat F${i}/baseline_table.dat | wc -l`
    ns=`ls F${i}/raw/S1*ALL*.SLC | wc -l`
    #if [ -s F${i}/baseline_table.dat -a "$tmp" == "S1" ]; then
    if [ $nb -gt 1 -a $nb -eq $ns ]; then
      echo "[$PROG]INFO: already done (from baseline_table.dat). Stage 2 skipped."              
    else
      cd F${i}  
      date > $file_lock  
      echo "[$PROG]INFO: working in `pwd` (Stage 2)"

      #1. uncompress the raw data
      #echo  sh_esa_s1_unzip_node ../$file_in iw${i}
      #echo  sh_esa_s1_unzip_node ../$file_in iw${i} | sh
      #echo  sh_esa_s1_unzip_node1b ../$file_in iw${i}
      #echo  sh_esa_s1_unzip_node1b ../$file_in iw${i} | sh
        
      cd raw
      pwd  
      preproc_batch_tops_esd.csh ../data.in dem.grd 2 1 >& ../log.algn #for new version GMT5SAR
  
      echo "[$PROG]INRO: re-geneate the correct version of baseline_table.dat file"
      #create prmlist from data.in
      cat ../data.in | awk -F- '{print "S1_"substr($5,1,8)"_ALL_F"iw_i".PRM"}' iw_i=$i > prmlist
      echo "get_baseline_table.csh prmlist `head -1 prmlist`"
      echo "get_baseline_table.csh prmlist `head -1 prmlist`" | sh
      \cp -fp baseline_table.dat ../
  
      cd .. #return from raw
  
      \rm -rf $file_lock
  
      echo "[$PROG]INRO: return to `pwd`"
      cd ..
    
    fi #end-of-align
    fi
    #<<<(2)
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 2<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 3>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    if [ $session_stage_id -lt 3 ]; then
      continue
    fi
    #stage 3. dem2topo_ra
    #>>>(3)
    #if [[ "${session_stage[@]}" =~ "3" ]]; then
    is_in=`echo 3 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then


    tmp=`head -1 F${i}/baseline_table.dat | awk '{print substr($1,1,2)}'`
    if [ "$tmp" != "S1" ]; then
      echo "[$PROG]WARNING: baseline_table.dat in F${i} NOT valid! Stage 3 skipped."
      continue
    fi

    #

    if [ -s F${i}/topo/trans.dat  -a  -s F${i}/topo/topo_ra.grd -a -s F${i}/batch_tops.config ]; then
      echo "[$PROG]INFO: dem2topo_ra already done! Skipped."
      
      proc_stage=`grep 'proc_stage' F${i}/batch_tops.config | awk -F= '{print $2}'`
      echo proc_stage $proc_stage    
      if [ $proc_stage -eq 1 ]; then
        \cp -f F${i}/batch_tops.config F${i}/_tmp_config
        sed -e "s/proc_stage.*/proc_stage = 2/" F${i}/_tmp_config > F${i}/batch_tops.config
        
      fi
      
      threshold_snaphu=`grep 'threshold_snaphu' F${i}/batch_tops.config | awk -F= '{print $2}'`
      is_zero=`echo $threshold_snaphu | awk '{if ($1==0){print 1}else{print 0}}'`
      echo threshold_snaphu $threshold_snaphu  is zero $is_zero  
      if [ $is_zero -eq 1 ]; then
        \cp -f F${i}/batch_tops.config F${i}/_tmp_config
        sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" F${i}/_tmp_config > F${i}/batch_tops.config
      fi
      #pwd
      #exit 
      
    else

      cd F${i}
      pwd
      #exit  
   
      date > $file_lock
  
      if [ ! -s batch_tops.config ]; then
        sh_esa_s1_prep_proc_baseline -file baseline_table.dat
      fi
      master=`grep master_image batch_tops.config | awk '{print $3}'`
  
      echo " "
      echo "DEM2TOPOPHASE.CSH - START"
      echo "USER SHOULD PROVIDE DEM FILE"
      cd topo
      cp ../raw/$master.PRM ./master.PRM
      ln -s ../raw/$master.LED .
      if [ -s dem.grd ]; then
        if [ "x$region_cut" == "x" ]; then
          time dem2topo_ra.csh master.PRM dem.grd
        else
          cut_slc master.PRM junk $region_cut 1
          mv junk.PRM master.PRM
          time dem2topo_ra.csh master.PRM dem.grd
        fi
      else
        echo "no DEM file found: " dem.grd
        continue
      fi
      cd .. #return from topo to F?
      echo "DEM2TOPOPHASE.CSH - END"
  
      \cp -f batch_tops.config _tmp_config
      sed -e "s/proc_stage.*/proc_stage = 2/" _tmp_config > batch_tops.config
      \cp -f batch_tops.config _tmp_config
      sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" _tmp_config > batch_tops.config
  
      \rm -rf $file_lock
      cd .. # return from F?
    fi
    fi
    #<<<(3)
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 3<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 4>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    if [ $session_stage_id -lt 4 ]; then
      continue
    fi
    #stage 4. intf_tops
    #>>>(4)
    #if [[ "${session_stage[@]}" =~ "4" ]]; then
    is_in=`echo 4 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then


    if [ ! -s F${i}/topo/trans.dat  -o  ! -s F${i}/topo/topo_ra.grd ]; then
      echo "[$PROG]WARNING: DEM files (trans.dat, topo_ra.grd) in F${i}/topo NOT available! Stage 4 skipped."
      continue
    fi
    if [ ! -s F${i}/intf.in ]; then
      echo "[$PROG]WARNING: intf.in in F${i} NOT available! Stage $session_stage kipped."
      continue
    fi
    
    proc_stage=`grep 'proc_stage' F${i}/batch_tops.config | awk -F= '{print $2}'`
    if [ $proc_stage -ne 2 ]; then
      echo "[$PROG]WARNING: wrong processing stage ($proc_stage) in F${i}/batch_tops.config! Stage 4 skipped."
      continue
    fi
      

    #
    cd F${i}
    pwd
    
    threshold_snaphu=`grep 'threshold_snaphu' batch_tops.config | awk -F= '{print $2}'`
    is_zero=`echo $threshold_snaphu | awk '{if ($1==0){print 1}else{print 0}}'`
    echo threshold_snaphu $threshold_snaphu  is zero $is_zero

    if [ $is_zero -eq 1 ]; then
      \cp -f batch_tops.config _tmp_config
      sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" _tmp_config > batch_tops.config
    fi
    
    date > $file_lock 
    
    sh_slurm_intf_tops -file intf.in -delay $delay
    #sh_slurm_intf_tops_fls -file intf.in -delay $delay

    
    \rm -rf $file_lock
    cd .. # return from F?
    fi
    #<<<(4)
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 4<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    


    pwd
    #exit


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 5>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    if [ $session_stage_id -lt 5 ]; then
      continue
    fi
    #stage 5. sbas
    #>>>5
    #if [[ "${session_stage[@]}" =~ "5" ]]; then
    is_in=`echo 5 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then


      if [ ! -d F${i}/intf_all ]; then
        echo "[]WARNING: F${i}/intf_all not exist!"
        continue
      fi      
      
      cd F${i}
      pwd
      
      intf_list_paths=`find . -maxdepth 1 -type d -name "b1-${t2_sbas}*"|sort`
      if [ "$intf_list_paths" == "" ]; then
        echo "[]WARNING: no apriori interferograms pairs (b1-*/*.tab1)!! "
        continue
      fi
      
      date > $file_lock
      hostname >> $file_lock
      
      echo "sh_sar_cp_los_ll_png"
      echo "sh_sar_cp_los_ll_png" | sh
      
      nl_intf_in=`cat intf.in | wc -l`
      n_intf_in_min=`expr $nl_intf_in - $n_intf_sbas_skip`
      nl_intf_all=`find intf_all_los_ll_png -maxdepth 1 -type f -name "*.png" | wc -l`
      if [ $n_intf_in_min -gt $nl_intf_all ]; then
        echo "[$PROG]WARNING: intf not finished ($n_intf_in_min vs. $nl_intf_all)!"
        \rm -f $file_lock
        cd ..
        continue
      fi
      
      for intf_list_path in $intf_list_paths; do
        if [ ! -s $intf_list_path/intf.tab1 -o ! -s  $intf_list_path/scene.tab1 ]; then
          echo "[]WARNING: missing intf.tab1 or scene.tab1 in $intf_list_path!!"
          continue
        fi 
        echo "\cp -f $intf_list_path/*.tab1 ."
        echo "\cp -f $intf_list_path/*.tab1 ." | sh

        t1_sbas_i=`basename $intf_list_path | awk '{print substr($1,2)}' | awk -F- '{print $1}'`
        t2_sbas_i=`basename $intf_list_path | awk '{print substr($1,2)}' | awk -F- '{print $2}'`
        echo sh_sar_scene_tab_gap -t2_intf $t2_sbas_i
        timestr=`sh_sar_scene_tab_gap -t2_intf $t2_sbas_i | grep TIME_INTF_START_END | sed -e 's/TIME_INTF_START_END//g'`
        

        echo sar_sbas_tab_from_png $timestr
        echo sar_sbas_tab_from_png $timestr| sh
        echo sh_sar_plot_intf_tab
        echo sh_sar_plot_intf_tab | sh
        
        out_sbas_path=`sh_esa_s1_call_sbas -t1 $t1_sbas_i -t2 $t2_sbas_i -r 2 -exec n | grep OUT_SBAS_PATH | awk '{print $2}'`
        echo out_sbas_path $out_sbas_path
        if [ -d $out_sbas_path ]; then
          echo "[]INFO: already exist ($out_sbas_path)."
          continue
        fi
        
        echo sh_slurm_sbas -delay 10 -t1 $t1_sbas_i -t2 $t2_sbas_i
        echo sh_slurm_sbas -delay 10 -t1 $t1_sbas_i -t2 $t2_sbas_i | sh
        #break
        
      done
      
      #if [ ! -s intf.tab1 ]; then
      #  echo sh_esa_s1_prep_sbas -t1 $t1_sbas -t2 $t2_sbas
      #  sh_esa_s1_prep_sbas -t1 $t1_sbas -t2 $t2_sbas >> $file_log
      #fi
      #ni1=`cat intf.tab1 | wc -l`
      #if [ -s intf.tab ]; then
      #  ni2=`cat intf.tab | wc -l`
      #else
      #  ni2=0
      #fi
      #if [ $ni1 -ne $ni2 ]; then
      #  sh_sar_cp_los_ll_png unwrap_mask_ll.png >> $file_log
      #  sh_sar_intf_tab_from_phase_files >> $file_log
      #fi 
      #if [ -s intf.tab -a -s scene.tab ]; then
      #  echo "sh_esa_s1_call_sbas -t1 $t1_sbas -t2 $t2_sbas -r 2"
      #  sh_esa_s1_call_sbas -t1 $t1_sbas -t2 $t2_sbas -r 2  >> $file_log
      #fi

      \rm $file_lock  
      #pwd
      cd ..
      #pwd
      #exit
    fi
    
    #<<<5
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 5<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 6>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>6. update alignment
    is_in=`echo 6 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then

      if [ ! -d F${i} ]; then
        echo "[$PROG]WARNING: processing directory F${i} NOT exist! "
        continue
      fi
      #continue
      if [ ! -s F${i}/data.in ]; then
        echo "[$PROG]WARNING: no data.in for expt ($expt F${i})! "
        continue
      fi
      if [ ! -s F${i}/baseline_table.dat ]; then
        echo "[$PROG]WARNING: no baseline_table.dat for expt ($expt F${i})! "
        continue
      fi

      cd F${i}
      pwd
      echo "sh_esa_s1_align_node_group -file ../$file_in -iw iw${i}"
      echo "sh_esa_s1_align_node_group -file ../$file_in -iw iw${i}" | sh

      cd ..
      #exit 1
    fi
    #<<<6
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 6<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 7>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>7. downsample interferograms (intf_all)
    is_in=`echo 7 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i}/intf_all ]; then
        continue
      fi

      cd F${i}
      echo "sh_esa_s1_intf_grd_resample"
      echo "sh_esa_s1_intf_grd_resample" | sh

      pwd
      cd ..
      #exit 1
    fi
    #<<<7
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 7<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 8>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>8
    is_in=`echo 8 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi
      
      cd F${i}
      pwd
      echo stage 8
      cd ..
      #exit 1
    fi
    #<<<8
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 8<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 9>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>9
    is_in=`echo 9 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi

      cd F${i}
      echo stage 9
      pwd
      cd ..
      #exit 1
    fi
    #<<<9
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 9<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>10>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>10
    is_in=`echo 10 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi

      cd F${i}
      pwd
      echo stage 10
      cd ..
      #exit 1
    fi
    #<<<10
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<10<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>11>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    #>>>11. create intf.in
    is_in=`echo 11 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -s F${i}/baseline_table.dat ]; then
        continue
      fi
 
      cd F${i}
      pwd
      wc -l intf.in baseline_table.dat
      echo sh_esa_s1_prep_proc_baseline -min_interval $t1_intf -max_interval $t2_intf -update_config n
      echo sh_esa_s1_prep_proc_baseline -min_interval $t1_intf -max_interval $t2_intf -update_config n | sh > /dev/null

      wc -l intf.in
      #echo 11
      cd ..
      #exit 1
    fi
    #<<<11
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<11<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>12>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>12. clean slurm temporary files
    is_in=`echo 12 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    if [[ "$is_in" == "1" ]]; then
      if [ ! -d F${i} ]; then
        continue
      fi

      cd F${i}
      pwd
      echo "\rm slurm*"
      \rm slurm*
      cd ..
      #exit 1
    fi
    #<<<12
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<12<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>13>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   #>>>13. unzip S1 SLC files to temporary directory
    is_in=`echo 13 $session_stage | awk '{for(i=2;i<=NF;i++){if($1==$i){print 1}}}'`
    #file_unzip='input.lst.proc'
    #file_unzip='input.lst.init'
    #file_unzip='input.lst.ok'
    if [[ "$is_in" == "1" ]]; then
      if [ ! -s $file_unzip ]; then
        continue
      fi

      pwd
      echo "sh_esa_s1_unzip_node -file $file_in -iw iw${i} -update y"
      echo "sh_esa_s1_unzip_node -file $file_in -iw iw${i} -update y" | sh >> $file_log 
      #echo "sh_esa_s1_unzip_node1b $file_in iw${i}"
      #echo "sh_esa_s1_unzip_node1b $file_in iw${i}" | sh >> $file_log 

      #exit 1
    fi
    #<<<13
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<13<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<





  done # end-of-loop-F1/2/3
  #exit


#------------------------------------------------------------------------------


  cd $oldpath
done
