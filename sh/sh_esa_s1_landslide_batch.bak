#!/bin/sh

# Name:
#   sh_esa_s1_landslide_batch
#

# Purpose:
#

# Example:
#

# Modifications:
#

# Algorigthm:
#

# Dependency:
#

PROG=sh_esa_s1_landslide_batch

host=`hostname`

session_stage=
#locking files
# 9 - all levels
# 1 - tiff cut/merge
# 2 - align
# 3 - dem2topo_ra
# 4 - intf

delay=30 #time of delay for paralleling tasks, default 30 seconds

file=proc.list

while [ "$1" != "" ]; do
  case $1 in
   -delay)
      delay=$2
      ;;
    -file)
      file=$2
      ;;
    -stage)
      session_stage=$2
      ;;
    *)
      echo "[$PROG]ERROR: invalid option ($1)!!"
      exit 1
      ;;
  esac

  shift 2
done

#echo session_stage is $session_stage
case $session_stage in
  1)
    stage_name='tiff_cut_merge'
    ;;
  2)
    stage_name='alignment'
    ;;
  3)
    stage_name='dem2topo_ra'
    echo stage_name $stage_name
    ;;
  4)
    stage_name='intf'
    ;;
  *)
    echo "[$PROG]ERROR: invalid processing stage ($session_stage)!!"
    echo "[$PROG]INFO: $PROG -stage n"
    echo "[$PROG]INFO:   stage:"
    echo "[$PROG]INFO:     1 - cut/merge tiff files"
    echo "[$PROG]INFO:     2 - alignment"
    echo "[$PROG]INFO:     3 - dem2topo_ra"
    echo "[$PROG]INFO:     4 - intf_tops"
    echo "[$PROG]INFO:"
    exit 1
    ;;
esac

file_lock="${session_stage}.${stage_name}.${host}.lock"
echo file_lock $file_lock
#exit

oldpath=`pwd`

grep '^ ' $file> .tmp.expts
expts=`cat .tmp.expts`
np=`cat .tmp.expts | wc -l`
echo "# expt: $np"
#exit

pi=0
for expt in $expts; do
  echo processing $expt
  cd $expt
  file_in=input.lst.ok.2020

  file=input.lst.ok
  if [ ! -s $file ]; then
    file=`ls over*.txt`
  fi
  echo input file is $file

  tmp=`grep '^ ' $file | grep '_2020'`
  if [ "$tmp" == "" ]; then
    echo "[]WARNING: no data for year 2020 ($expt)!"
    continue
  fi

  grep '^ ' $file | grep '_2020'|sort  > $file_in

  wc -l $file_in


  if [ ! -s $file_in ]; then
    echo "[$PROG]WARNING: no data file ($file_in) for expt ($expt)!"
    continue
  fi

  #2. run intf

  for i in 1 2 3 ; do
    echo "[$PROG]INFO: processing F${i}"

    #tmp=`ls F${i}/*.lock`
    tmp=`find ./F${i}/ -maxdepth 1 -name  "*.lock"`
    if [ "$tmp" != "" ]; then   # if locked by any stage, skip it
      echo "[$PROG]WARNING: session in `pwd`/F${i} has been locked!! Skipped."
      echo "$tmp"
      is_clear_lock=0
      if [ $is_clear_lock -eq 1 ]; then
        for tmp1 in $tmp; do
          echo "clearing locking $tmp1"
          \rm -f $tmp1
        done
      fi
      continue
    fi



    #stage 1. tiff cut/merge
    #>>>(1)
    if [ $session_stage -eq 1 ]; then
      if [ -d F${i} ]; then
        echo "[$PROG]WARNING: processing directory F${i} already exist! Skipped."
        continue
      fi
      #continue

      mkdir -p F${i}
      cd F${i}

      date > $file_lock

      #1. uncompress the raw data
      echo  sh_esa_s1_unzip_node ../$file_in iw${i}
      echo  sh_esa_s1_unzip_node ../$file_in iw${i} | sh

      echo sh_esa_s1_run_tsa -file ../$file_in -iw iw${i} -roi ../pins.kml -skip_align y
      echo sh_esa_s1_run_tsa -file ../$file_in -iw iw${i} -roi ../pins.kml -skip_align y | sh

      \rm -rf $file_lock
      cd .. #return from F?
    fi
    #<<<(1)



    #stage 2. alignment
    #>>>(2)
    #check whether previous work has been done
    if [ $session_stage -ge 2 ]; then
      if [ ! -d F${i} ]; then
        echo "[$PROG]WARNING: processing directory F${i} NOT exist! Skipped."
        continue
      fi
      #continue

      if [ ! -s F${i}/data.in ]; then
        echo "[$PROG]WARNING: no data.in for expt ($expt F${i})!"
        continue
      fi

    fi #end-of-proc_stage_ge_2

    #start stage 2 processing
    if [ $session_stage -eq 2 ]; then
      #
      if [ -s F${i}/baseline_table.dat ]; then
        tmp=`head -1 F${i}/baseline_table.dat | awk '{print substr($1,1,2)}'`
        if [ "$tmp" == "S1" ]; then
          echo "[$PROG]INFO: already done (from baseline_table.dat). Skipped."
          continue
        fi
      fi


      cd F${i}

      date > $file_lock

      echo "[$PROG]INFO: working in `pwd` "

      cd raw
      pwd
      if [ ! -s baseline_table.dat ]; then
        preproc_batch_tops.csh ../data.in dem.grd 1 >& ../log.prep
        gmt psconvert -A -Tejf baseline.ps
        cp -f baseline.* ../
        cp -f baseline_table.dat ../
      fi

      preproc_batch_tops_esd.csh ../data.in dem.grd 2 1 >& ../log.algn #for new version GMT5SAR

      echo "[$PROG]INRO: re-geneate the correct version of baseline_table.dat file"
      #create prmlist from data.in
      cat ../data.in | awk -F- '{print "S1_"substr($5,1,8)"_ALL_F"iw_i".PRM"}' iw_i=$i > prmlist
      echo "get_baseline_table.csh prmlist `head -1 prmlist`"
      echo "get_baseline_table.csh prmlist `head -1 prmlist`" | sh
      \cp -fp baseline_table.dat ../

      cd .. #return from raw

      \rm -rf $file_lock

      echo "[$PROG]INRO: return to `pwd`"
      cd ..
    fi  #end-of-align
    #<<<(2)



    #stage 3. dem2topo_ra
    #>>>(3)
    if [ $session_stage -ge 3 ]; then
      tmp=`head -1 F${i}/baseline_table.dat | awk '{print substr($1,1,2)}'`
      if [ "$tmp" != "S1" ]; then
        echo "[$PROG]WARNING: baseline_table.dat in F${i} NOT valid! Skipped."
        continue
      fi
    fi

    #
    if [ $session_stage -eq 3 ]; then

      if [ -s F${i}/topo/trans.dat  -a  -s F${i}/topo/topo_ra.grd ]; then
        echo "[$PROG]INFO: dem2topo_ra already done! Skipped."
        
        proc_stage=`grep 'proc_stage' F${i}/batch_tops.config | awk -F= '{print $2}'`
        echo proc_stage $proc_stage    
        if [ $proc_stage -eq 1 ]; then
          \cp -f F${i}/batch_tops.config F${i}/_tmp_config
          sed -e "s/proc_stage.*/proc_stage = 2/" F${i}/_tmp_config > F${i}/batch_tops.config
          
        pwd
        exit 
        fi
        
        threshold_snaphu=`grep 'threshold_snaphu' F${i}/batch_tops.config | awk -F= '{print $2}'`
        is_zero=`echo $threshold_snaphu | awk '{if ($1==0){print 1}else{print 0}}'`
        echo threshold_snaphu $threshold_snaphu  is zero $is_zero  
        if [ $is_zero -eq 1 ]; then
          \cp -f F${i}/batch_tops.config F${i}/_tmp_config
          sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" F${i}/_tmp_config > F${i}/batch_tops.config
        fi
        continue
      fi

      cd F${i}
      pwd
      #exit

   
      date > $file_lock

      if [ ! -s batch_tops.config ]; then
        sh_esa_s1_prep_proc_baseline -file baseline_table.dat
      fi
      master=`grep master_image batch_tops.config | awk '{print $3}'`

      echo " "
      echo "DEM2TOPOPHASE.CSH - START"
      echo "USER SHOULD PROVIDE DEM FILE"
      cd topo
      cp ../raw/$master.PRM ./master.PRM
      ln -s ../raw/$master.LED .
      if [ -s dem.grd ]; then
        if [ "x$region_cut" == "x" ]; then
          time dem2topo_ra.csh master.PRM dem.grd
        else
          cut_slc master.PRM junk $region_cut 1
          mv junk.PRM master.PRM
          time dem2topo_ra.csh master.PRM dem.grd
        fi
      else
        echo "no DEM file found: " dem.grd
        continue
      fi
      cd .. #return from topo to F?
      echo "DEM2TOPOPHASE.CSH - END"

      \cp -f batch_tops.config _tmp_config
      sed -e "s/proc_stage.*/proc_stage = 2/" _tmp_config > batch_tops.config
      \cp -f batch_tops.config _tmp_config
      sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" _tmp_config > batch_tops.config

      \rm -rf $file_lock
      cd .. # return from F?
    fi
    #<<<(3)



    #stage 4. intf_tops
    #>>>(4)
    if [ $session_stage -ge 4 ]; then
      if [ ! -s F${i}/topo/trans.dat  -o  ! -s F${i}/topo/topo_ra.grd ]; then
        echo "[$PROG]WARNING: DEM files (trans.dat, topo_ra.grd) in F${i}/topo NOT available! Skipped."
        continue
      fi
      if [ ! -s F${i}/intf.in ]; then
        echo "[$PROG]WARNING: intf.in in F${i} NOT available! Skipped."
        continue
      fi
      
      proc_stage=`grep 'proc_stage' F${i}/batch_tops.config | awk -F= '{print $2}'`
      if [ $proc_stage -ne 2 ]; then
        echo "[$PROG]WARNING: wrong processing stage ($proc_stage) in F${i}/batch_tops.config! Skipped."
        continue
      fi
      
    fi

    #
    if [ $session_stage -eq 4 ]; then
      cd F${i}
      pwd
      
      threshold_snaphu=`grep 'threshold_snaphu' batch_tops.config | awk -F= '{print $2}'`
      is_zero=`echo $threshold_snaphu | awk '{if ($1==0){print 1}else{print 0}}'`
      echo threshold_snaphu $threshold_snaphu  is zero $is_zero

      if [ $is_zero -eq 1 ]; then
        \cp -f batch_tops.config _tmp_config
        sed -e "s/threshold_snaphu.*/threshold_snaphu = 0.01/" _tmp_config > batch_tops.config
      fi
      
      date > $file_lock 
      
      sh_slurm_intf_tops -file intf.in -delay $delay
      
      \rm -rf $file_lock
      cd .. # return from F?
    fi
    #<<<(4)
    


    pwd
    #exit
  done # end-of-loop-F1/2/3



  #clear uncompressed temporary S1 data
  if [ $session_stage -eq 1 ]; then
    sed -i '1d' ../.tmp.expts

    expt1=`echo $expt | awk -F_ '{print $1}'`
    expt2=`echo $expt | awk -F+ '{print $2}'`

    tmp1=`grep $expt1 ../.tmp.expts`
    if [ "$expt2" != "" ]; then
      tmp2=`grep $expt2 ../.tmp.expts`
    fi
    if [ "$tmp1" == "" -a "$tmp2" == "" ]; then
      echo "[$PROG]INFO: clean temporary uncompressed observation files ..."
      echo sh_esa_s1_unzip_clean $file_in
      echo sh_esa_s1_unzip_clean $file_in | sh

    fi
  fi

  cd $oldpath
done
