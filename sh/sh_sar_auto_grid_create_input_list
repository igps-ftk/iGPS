#!/bin/sh

# Name:
#   sh_sar_auto_grid_create_input_list
#   

# Purpose:
#   create/update input.lst files in /sar/proc_gmtsat/auto_grid based upon observations files in /sar/s1

# Example:
#   

# Modifications:
#   

# Algorigthm:
#   

# Dependency:
#   

. ${HOME}/.bashrc

PROG=sh_sar_auto_grid_create_input_list


usage(){
    echo "[$PROG]INFO: $PROG [-date YYYYMM ]"
    echo "[$PROG]INFO:       [-expt EXPT]"
    echo "[$PROG]INFO: "
}


#path_slc=/sar/s1

root_expt=/sar/proc_gmtsar/auto_grid

root_safe=/sar/s1/metainfo/manifest.safe
#root_safe=/g4c/safe

datestr=202001
#datestr=20200
expt=
is_update_list=n
file_tmp=_tmp_${PROG}_`date +%s`_$$

t1=19800101
t2=21991231

while [ "$1" != "" ]; do
  case $1 in
   -d|-date)
      datestr=$2
      ;;
    -e|-expt)
      expt=$2
      ;;
    -h|-H|--help|-help|"?")
      usage
      exit 0
      ;;
    -u|-update_list)
      is_update_list=$2
      ;;
    -t1)
      t1=$2
      ;;
    -t2)
      t2=$2
      ;;
    *)
      echo "[$PROG]ERROR: invalid option ($1)!!"
      echo "[$PROG]INFO: use $PROG -h for usage."
      exit 1
      ;;
  esac

  shift 2
done

if [ "$expt" == "" ]; then
  echo "[]ERROR: no expt input!!"
  exit 1
fi

#path=${path_slc}/${expt}
#echo path $path

find $root_safe/$expt -maxdepth 1 -type f -name "S1*IW*SLC*_20*.manifest.safe"|sort > $file_tmp
nf=`cat $file_tmp | wc -l`
if [ $nf -le 1 ]; then
  echo "[]WARNING: no enough scenes ($nf) in $root_safe/$expt!!"
  exit 1
fi

y1=`echo $t1 | awk '{print substr($1,1,4)}'`
m1=`echo $t1 | awk '{print substr($1,5,2)}'`
d1=`echo $t1 | awk '{print substr($1,7,2)}'`
y2=`echo $t2 | awk '{print substr($1,1,4)}'`
m2=`echo $t2 | awk '{print substr($1,5,2)}'`
d2=`echo $t2 | awk '{print substr($1,7,2)}'`
dyr1=`doy $y1 $m1 $d1 | tail -1 | awk '{print $3}'`
dyr2=`doy $y2 $m2 $d2 | tail -1 | awk '{print $3}'`

path_expt=${root_expt}/$expt
if [ ! -d $path_expt ]; then
  echo "mkdir -p $path_expt"
  echo "mkdir -p $path_expt" | sh
fi

file_config=${path_expt}/config.txt

cd $path_expt
pwd


if [ -s $file_config ]; then
  master_date=`grep -h '^ ' $file_config | awk '{if(index($0,"#")>0){print substr($0,1,index($0,"#")-1)}else{print $0}}' | grep master_date | tail -1 | awk '{print $3}' `
else
  tmp=`grep "_$datestr" $file_tmp`
  if [ "$tmp" == "" ]; then
    echo "[]no data in $datestr."
    exit 1
  fi

  master_date=`grep -h "_${datestr}" $file_tmp | sort | head -1 | awk -F\/ '{print $NF }' | awk -F_ '{print substr($6,1,8)}'`
fi
echo master_date $master_date
#wc -l $file_config
#cat $file_config
if [ ! -s ${file_config} ]; then
    echo " master_date = $master_date" > $file_config
fi

#exit

#create input.lst & input.lst.ok from overlapping statistics
echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/manifest.safe"
echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/manifest.safe" | sh


#if [ ! -s ${path_expt}/input.lst ]; then
#  grep -h $master_date $file_tmp | tail -1 | awk -F\/ '{print "",$5}' > ${path_expt}/input.lst
#  grep -hv $master_date $file_tmp | awk -F\/ '{print "",$5}' >> ${path_expt}/input.lst
#else
#  wc -l ${path_expt}/input.lst
#  echo "[]INFO: input.lst file exist in $path_expt. Skipped re-creating."
#fi

#exit
##tmp=`ls ${path_expt}/overlapping.*.txt`
##tmp=
##if [ "$tmp" == "" ]; then
##
##  opath_safe=${path_expt}/safe
##  if [ ! -d $opath_safe ]; then
##    mkdir -p $opath_safe
##  fi
##
##  while read file; do
##    #echo $file
##    bname=`basename $file | awk -F. '{print $1}'`
##
##    ofile_safe=${opath_safe}/${bname}.manifest.safe
##    if [ ! -s $ofile_safe ]; then
##      file_safe=/sar/s1/metainfo/manifest.safe/${expt}/${bname}.manifest.safe
##      file_safe2=/sar/esa.sentinel-1/metainfo/manifest.safe/all/${bname}.manifest.safe
##      file_safe3=/sar/s1b/metainfo/manifest.safe/${expt}/${bname}.manifest.safe
##      if [ -s $file_safe ]; then
##        \cp -fp $file_safe ${opath_safe}
##      else
##        if [ -s $file_safe2 ]; then
##          \cp -fp $file_safe2 ${opath_safe}
##        else
##          if [ -s $file_safe3 ]; then
##            \cp -fp $file_safe3 ${opath_safe}
##          else
##            echo "[]WARNING: no safe file for $file!"
##          fi
##        fi
##      fi
##    fi
##  done < $file_tmp
##  #target=`grep -h $master_date $file_tmp | tail -1 | awk '{print $1}'`
##  tmp=`ls ${opath_safe}/*$master_date*|sort|tail -1`
##  if [ "$tmp" == "" ]; then
##    echo "[]WARNING: no manifest.safe file for $master_date!!"
##    exit 1
##  fi
##  target=`basename $tmp`
##
##  ls $opath_safe/*.safe | awk -F\/ '{print $NF}' | sort | uniq > ${file_tmp}.safe
##  if [ -s input.lst ]; then
##    grep -h '^ ' input.lst | awk '{print $1}' | sort |uniq > ${file_tmp}.in
##  else
##    echo "" > ${file_tmp}.in
##  fi
##  tmp=`/bin/diff ${file_tmp}.safe ${file_tmp}.in`
##  if [ "$tmp" != "" ]; then
##    #echo esa_s1_manifest_overlap $opath_safe $target $path_expt
##    #esa_s1_manifest_overlap $opath_safe $target $path_expt 
##    echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/"
##    echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/" | sh
##  fi
##
##else
##  echo "number of lines: `grep '^ ' $tmp |wc -l`"
##  echo "[]INFO: overlap file exist ($tmp). Skipped."
##fi
##
##
#file_overlap=`ls ${path_expt}/overlapping.*${master_date}*.txt`
file_overlap=`ls ${path_expt}/input.lst.ok`
if [ "$file_overlap" == "" ]; then
  echo "[]ERROR: overlap file not exist ($file_overlap)!!"
  exit 1
fi

if [ ! -s ${path_expt}/input.lst.init ]; then
  file_overlap=`ls ${path_expt}/overlapping.*${master_date}*.txt`
  if [ "$file_overlap" == "" ]; then
    echo "[]ERROR: overlap file not exist ($file_overlap)!!"
    exit 1
  fi
  grep '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.init
  grep '^ ' $file_overlap | grep -v $master_date |sort |tail -1 >> ${path_expt}/input.lst.init
  cat ${path_expt}/input.lst.init
  wc -l ${path_expt}/input.lst.init
else
  echo "[]input.lst.init file exist in $path_expt. Skipped."
fi

if [ ! -s ${path_expt}/input.lst.init ]; then
  echo "[]ERROR:input.lst.init not exist!!"
  exit 1
fi
nl_in=`grep '^ ' ${path_expt}/input.lst.init | grep '_IW_SLC__' | wc -l`
if [ $nl_in -ne 2 ]; then
  echo "[]ERROR:wrong number of lines in input.lst.init ($nl_in)!!"
  exit 1
fi


nl_bl=0
file_bl=
iws='1 2 3'
for iw in $iws; do
  if [ -s F${iw}/baseline_table.dat ]; then
    nl_bi=`cat F${iw}/baseline_table.dat | wc -l`
    if [ $nl_bi -gt $nl_bl ]; then
      nl_bl=$nl_bi
      file_bl=F${iw}/baseline_table.dat
    fi
  fi
done

echo "baseline_table.dat: $file_bl"

\rm -f _tmp_input_lst_proc
touch _tmp_input_lst_proc
if [ "$file_bl" != "" ]; then
  #S1_20200103_ALL_F1 2020002.4344741255 2192 0.000000000000 0.000000000000
  while read line; do
    s1id=`echo $line | awk '{print substr($1,4,8)}'`
    grep '^ ' input.lst.ok | grep $s1id >> _tmp_input_lst_proc
  done < $file_bl
fi


while read line; do
  s1id=`echo $line | awk -F_ '{print substr($6,1,8)}'`
  tmp=`cat _tmp_input_lst_proc | grep $s1id`
  if [ "$tmp" != "" ]; then
    continue
  fi
  
  y3=`echo $s1id | awk '{print substr($1,1,4)}'`
  m3=`echo $s1id | awk '{print substr($1,5,2)}'`
  d3=`echo $s1id | awk '{print substr($1,7,2)}'`
  dyr3=`doy $y3 $m3 $d3 | tail -1 | awk '{print $3}'`

  is_out=`echo $dyr1 $dyr2 $dyr3 | awk '{if($3>=$1&&$3<=$2){print 0}else{print 1}}'`
  if [ $is_out -eq 1 ]; then
    continue
  fi

   echo " $line" >>  _tmp_input_lst_proc
done < input.lst.ok

#cat  _tmp_input_lst_proc
wc -l  _tmp_input_lst_proc
\mv -f _tmp_input_lst_proc input.lst.proc
exit
#>>>>>>>>>obsolete<<<<<<<<<
if [ -s input.lst.proc ]; then

  no=`grep -h '^ ' $file_overlap | wc -l`
  no1=`grep -h '^ ' $file_overlap | grep '_202' | wc -l` #2021-01-27 only processing data of 2020
  no2=`grep -h '^ ' $file_overlap | grep '_201' | wc -l`
  no=`expr $no1 + $no2`


  ni=`grep -h '^ ' ${path_expt}/input.lst.proc | wc -l`
  if [ -s ${path_expt}/F1/data.in ]; then
    ni=`cat ${path_expt}/F1/data.in | wc -l`
  else
    ni=1
  fi

  if [ $no -gt $ni ]; then
    #have new data
    echo "\mv input.lst.proc input.lst.proc.`date +%Y%m%d`T`date +%H%M%S`"
    echo "\mv input.lst.proc input.lst.proc.`date +%Y%m%d`T`date +%H%M%S`" | sh

    grep -h '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.proc
   
    #grep -h '^ ' $file_overlap | grep -v $master_date |sort >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_201' |sort  >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_202' |sort  >> ${path_expt}/input.lst.proc


  else
    echo "[]INFO: no new data ($no vs. $ni)."
  fi
else
    grep -h '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.proc
    #grep -h '^ ' $file_overlap | grep -v $master_date |sort >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_2021' |sort  >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_2022' |sort  >> ${path_expt}/input.lst.proc


fi


\rm -f $file_tmp
