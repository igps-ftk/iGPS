#!/bin/sh

# Name:
#   sh_sar_auto_grid_run_expt
#   

# Purpose:
#   

# Example:
#   

# Modifications:
#   

# Algorigthm:
#   

# Dependency:
#   


PROG=sh_sar_auto_grid_run_expt



root_expt=/sar/proc_gmtsar/auto_grid

path_old=`pwd`

timestamp=`date | sed -e 's/ /_/g' | sed -e 's/:/-/g'`
file_lock=${root_expt}/script/_tmp_${PROG}.lock

if [ -s $file_lock ]; then
  echo "[$PROG]ERROR: session locked by $file_lock!!"
  exit 1
fi

usage(){
  echo "[$PROG]Usage: ${PROG} "
  echo "[$PROG]Usage: e.g.,"
  echo "[$PROG]Usage:  "
}

expt=
#expt=A142_0081
#expt=A113_0101

t1_list=20200101

iws='iw1 iw2 iw3'
#iws='iw2 iw3'

is_update_input_lst=y

while [ "$1" != "" ]; do
  case $1 in
    -e|-expt)
      expt=$2
      ;;
    -l|list)
      is_update_input_lst=$2
      ;;
    -t1_list)
      t1_list=$2
      ;;
    *)
      echo "[$PROG]ERROR: invalid option ($1)!!"
      usage
      exit 1
      ;;
  esac
  shift 2  
done


file_queue=
if [ "$expt" = "" ]; then
  echo "[$PROG]INFO: no input experiment. Searching queued sessions ..."
  file_queue=`find /sar/proc_gmtsar/auto_grid/script/event/queue/ -maxdepth 1 -type f -name "*.list" |sort | head -1`
  if [ "$file_queue" == "" ]; then
    exit 1
  else
    echo "[$PROG]INFO: queuing $file_queue ..."
    expt=`basename $file_queue | awk -F. '{print $2}'`
  fi
fi

echo expt $expt
#exit

if [ ! -d $root_expt/$expt ]; then
  echo "[$PROG]ERROR: experiment not exist ($root_expt/$expt)!!"
  exit 1
fi


date > $file_lock
hostname >> $file_lock
echo "expt: $expt" >> $file_lock
echo "iws: $iws" >> $file_lock

if [ "$is_update_input_lst" == "y" ]; then
  #create input.lst.*
  echo sh_sar_auto_grid_batch -expt $expt -stage 15 -t1_list $t1_list
  echo sh_sar_auto_grid_batch -expt $expt -stage 15 -t1_list $t1_list | sh
fi

for iw in $iws; do
  iw_id=`echo $iw | awk '{print substr($1,3,1)}'`
  status=`sh_sar_auto_grid_check_status -e $expt -iw $iw | awk '{print $3}'`

  if [ $status -lt 0 ]; then
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 0
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 0 | sh
  fi

  if [ $status -lt 1 ]; then
    #unzip slc files (init)
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 13
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 13 | sh

    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 1
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 1 | sh
  fi

  if [ $status -lt 2 ]; then
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 2
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 2 | sh
  fi

  if [ $status -lt 3 ]; then
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 3
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 3 | sh
  fi


  echo "[$PROG]INFO: checking whether all scenes in input.lst.proc have been aligned ..."
  ids_in=`grep '^ ' -h $root_expt/$expt/input.lst.proc | awk -F_ '{print substr($6,1,8)}' | sort`
  echo ids_in $ids_in
  ids_rem=
  for id_in in $ids_in; do
    tmp=`grep $id_in -h $root_expt/$expt/F${iw_id}/baseline_table.dat`
    if [ "$tmp" == "" ]; then
      ids_rem="$ids_rem $id_in"
    fi
  done
  echo "ids_rem $ids_rem"
  
  nl_bl=`cat $root_expt/$expt/F${iw_id}/baseline_table.dat | wc -l`
  nl_in=`cat $root_expt/$expt/input.lst.proc | wc -l`
  echo nl_bl nl_in $nl_bl $nl_in
  #if [ $nl_bl -lt $nl_in ]; then
  if [ "$ids_rem" != "" ]; then
    #unzip slc files (proc)
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 13 -sess_type proc
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 13 -sess_type proc | sh

    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 6 -sess_type proc
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 6 -sess_type proc | sh
  else
    echo "[$PROG]INFO:all scenes aligned. Cleaning temporary unzipped files ..."
    echo "sh_esa_s1_unzip_clean -file $root_expt/$expt/input.lst.proc -iw $iw"
    echo "sh_esa_s1_unzip_clean -file $root_expt/$expt/input.lst.proc -iw $iw" | sh
  fi

  #continue

  echo "[$PROG]INFO: checking whether all intfs have been genereated ..."
  nl_intf_in=`cat $root_expt/$expt/F${iw_id}/intf.in | wc -l`
  nl_intf_all=`find $root_expt/$expt/F${iw_id}/intf_all -maxdepth 1 -type d -name "20*_20*" | wc -l`
  echo nl_intf_in nl_intf_all $nl_intf_in $nl_intf_all
  intfs_rem=
  while read intf; do
    #S1_20200115_ALL_F1:S1_20200303_ALL_F1
    id1=`echo $intf | awk -F_ '{print $2}'`
    id2=`echo $intf | awk -F_ '{print $5}'`
    doy1=`grep $id1 $root_expt/$expt/F${iw_id}/baseline_table.dat | awk '{print substr($2,1,7)}'`    #S1_20200701_ALL_F1 2020182.4362703324 2372 94.970337878190 51.114555712299
    doy2=`grep $id2 $root_expt/$expt/F${iw_id}/baseline_table.dat | awk '{print substr($2,1,7)}'`
    #echo id1 id2 $id1 $id2 $doy1 $doy2
    
    if [ -s $root_expt/$expt/F${iw_id}/intf_all/${doy1}_${doy2}/unwrap_mask.grd ]; then
      continue
    fi
    
    #slurm_intf_tops_20210614_20210801.cmd
    if [ -s $root_expt/$expt/F${iw_id}/slurm_intf_tops_${id1}_${id2}.cmd ]; then
      continue
    fi
    
    intfs_rem="$intfs_rem $intf"
  done < $root_expt/$expt/F${iw_id}/intf.in
  echo intfs_rem $intfs_rem
  #exit
  
  #if [ $nl_intf_in -gt $nl_intf_all ]; then
  if [ "$intfs_rem" != "" ]; then
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 4
    echo sh_sar_auto_grid_batch -expt $expt -iw $iw -stage 4 | sh
  else
    echo "[$PROG]INFO:all intfs genereated or queued."
  fi

  #exit
done

if [ "$file_queue" != "" ]; then
  echo "\mv -f $file_queue /sar/proc_gmtsar/auto_grid/script/event/complete/"
  echo "\mv -f $file_queue /sar/proc_gmtsar/auto_grid/script/event/complete/" | sh
  echo " `date` $file_queue" >> /sar/proc_gmtsar/auto_grid/script/event/complete/done.txt
else
  echo " `date` $expt" >> /sar/proc_gmtsar/auto_grid/script/event/complete/done.txt
fi

\rm -f $file_lock
