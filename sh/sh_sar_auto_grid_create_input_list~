#!/bin/sh

# Name:
#   sh_sar_auto_grid_create_input_list
#   

# Purpose:
#   create/update input.lst files in /sar/proc_gmtsat/auto_grid based upon observations files in /sar/s1

# Example:
#   

# Modifications:
#   

# Algorigthm:
#   

# Dependency:
#   

. ${HOME}/.bashrc

PROG=sh_sar_auto_grid_create_input_list


usage(){
    echo "[$PROG]INFO: $PROG [-date YYYYMM ]"
    echo "[$PROG]INFO:       [-expt EXPT]"
    echo "[$PROG]INFO: "
}


#path_slc=/sar/s1

root_expt=/sar/proc_gmtsar/auto_grid
root_safe=/sar/s1/metainfo/safe.all/

datestr=202001
#datestr=20200
expt=
is_update_list=n
file_tmp=_tmp_${PROG}_`date +%s`_$$



while [ "$1" != "" ]; do
  case $1 in
   -d|-date)
      datestr=$2
      ;;
    -e|-expt)
      expt=$2
      ;;
    -h|-H|--help|-help|"?")
      usage
      exit 0
      ;;
    -u|-update_list)
      is_update_list=$2
      ;;
    *)
      echo "[$PROG]ERROR: invalid option ($1)!!"
      echo "[$PROG]INFO: use $PROG -h for usage."
      exit 1
      ;;
  esac

  shift 2
done

if [ "$expt" == "" ]; then
  echo "[]ERROR: no expt input!!"
  exit 1
fi

#path=${path_slc}/${expt}
#echo path $path

find $root_safe/$expt -maxdepth 1 -type f -name "S1*IW*SLC*_20*.manifest.safe"|sort > $file_tmp
nf=`cat $file_tmp | wc -l`
if [ $nf -le 1 ]; then
  echo "[]WARNING: no enough scenes ($nf) in $root_safe/$expt!!"
  exit 1
fi



path_expt=${root_expt}/$expt
if [ ! -d $path_expt ]; then
  echo "mkdir -p $path_expt"
  echo "mkdir -p $path_expt" | sh
fi

file_config=${path_expt}/config.txt

cd $path_expt
pwd


if [ -s $file_config ]; then
  master_date=`grep -h '^ ' $file_config | awk '{if(index($0,"#")>0){print substr($0,1,index($0,"#")-1)}else{print $0}}' | grep master_date | tail -1 | awk '{print $3}' `
else
  tmp=`grep "_$datestr" $file_tmp`
  if [ "$tmp" == "" ]; then
    echo "[]no data in $datestr."
    exit 1
  fi

  master_date=`grep -h "_${datestr}" $file_tmp | sort | head -1 | awk -F\/ '{print $NF }' | awk -F_ '{print substr($6,1,8)}'`
fi
echo master_date $master_date
#wc -l $file_config
#cat $file_config
if [ ! -s ${file_config} ]; then
    echo " master_date = $master_date" > $file_config
fi

#exit

#create input.lst & input.lst.ok from overlapping statistics
echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/"
echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/" | sh


#if [ ! -s ${path_expt}/input.lst ]; then
#  grep -h $master_date $file_tmp | tail -1 | awk -F\/ '{print "",$5}' > ${path_expt}/input.lst
#  grep -hv $master_date $file_tmp | awk -F\/ '{print "",$5}' >> ${path_expt}/input.lst
#else
#  wc -l ${path_expt}/input.lst
#  echo "[]INFO: input.lst file exist in $path_expt. Skipped re-creating."
#fi

#exit
##tmp=`ls ${path_expt}/overlapping.*.txt`
##tmp=
##if [ "$tmp" == "" ]; then
##
##  opath_safe=${path_expt}/safe
##  if [ ! -d $opath_safe ]; then
##    mkdir -p $opath_safe
##  fi
##
##  while read file; do
##    #echo $file
##    bname=`basename $file | awk -F. '{print $1}'`
##
##    ofile_safe=${opath_safe}/${bname}.manifest.safe
##    if [ ! -s $ofile_safe ]; then
##      file_safe=/sar/s1/metainfo/manifest.safe/${expt}/${bname}.manifest.safe
##      file_safe2=/sar/esa.sentinel-1/metainfo/manifest.safe/all/${bname}.manifest.safe
##      file_safe3=/sar/s1b/metainfo/manifest.safe/${expt}/${bname}.manifest.safe
##      if [ -s $file_safe ]; then
##        \cp -fp $file_safe ${opath_safe}
##      else
##        if [ -s $file_safe2 ]; then
##          \cp -fp $file_safe2 ${opath_safe}
##        else
##          if [ -s $file_safe3 ]; then
##            \cp -fp $file_safe3 ${opath_safe}
##          else
##            echo "[]WARNING: no safe file for $file!"
##          fi
##        fi
##      fi
##    fi
##  done < $file_tmp
##  #target=`grep -h $master_date $file_tmp | tail -1 | awk '{print $1}'`
##  tmp=`ls ${opath_safe}/*$master_date*|sort|tail -1`
##  if [ "$tmp" == "" ]; then
##    echo "[]WARNING: no manifest.safe file for $master_date!!"
##    exit 1
##  fi
##  target=`basename $tmp`
##
##  ls $opath_safe/*.safe | awk -F\/ '{print $NF}' | sort | uniq > ${file_tmp}.safe
##  if [ -s input.lst ]; then
##    grep -h '^ ' input.lst | awk '{print $1}' | sort |uniq > ${file_tmp}.in
##  else
##    echo "" > ${file_tmp}.in
##  fi
##  tmp=`/bin/diff ${file_tmp}.safe ${file_tmp}.in`
##  if [ "$tmp" != "" ]; then
##    #echo esa_s1_manifest_overlap $opath_safe $target $path_expt
##    #esa_s1_manifest_overlap $opath_safe $target $path_expt 
##    echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/"
##    echo "sh_esa_s1_expt_safe  -s /sar/s1/metainfo/safe.all/" | sh
##  fi
##
##else
##  echo "number of lines: `grep '^ ' $tmp |wc -l`"
##  echo "[]INFO: overlap file exist ($tmp). Skipped."
##fi
##
##
#file_overlap=`ls ${path_expt}/overlapping.*${master_date}*.txt`
file_overlap=`ls ${path_expt}/input.lst.ok`
if [ "$file_overlap" == "" ]; then
  echo "[]ERROR: overlap file not exist ($file_overlap)!!"
  exit 1
fi


if [ -s input.lst.proc ]; then

  no=`grep -h '^ ' $file_overlap | wc -l`
  no1=`grep -h '^ ' $file_overlap | grep '_202' | wc -l` #2021-01-27 only processing data of 2020
  no2=`grep -h '^ ' $file_overlap | grep '_201' | wc -l`
  no=`expr $no1 + $no2`


  ni=`grep -h '^ ' ${path_expt}/input.lst.proc | wc -l`
  if [ -s ${path_expt}/F1/data.in ]; then
    ni=`cat ${path_expt}/F1/data.in | wc -l`
  else
    ni=1
  fi

  if [ $no -gt $ni ]; then
    #have new data
    echo "\mv input.lst.proc input.lst.proc.`date +%Y%m%d`T`date +%H%M%S`"
    echo "\mv input.lst.proc input.lst.proc.`date +%Y%m%d`T`date +%H%M%S`" | sh

    grep -h '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.proc
   
    #grep -h '^ ' $file_overlap | grep -v $master_date |sort >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_201' |sort  >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_202' |sort  >> ${path_expt}/input.lst.proc


  else
    echo "[]INFO: no new data ($no vs. $ni)."
  fi
else
    grep -h '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.proc
    #grep -h '^ ' $file_overlap | grep -v $master_date |sort >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_2021' |sort  >> ${path_expt}/input.lst.proc
    grep -h '^ ' $file_overlap | grep -v $master_date | grep '_2022' |sort  >> ${path_expt}/input.lst.proc


fi

if [ ! -s ${path_expt}/input.lst.init ]; then
  file_overlap=`ls ${path_expt}/overlapping.*${master_date}*.txt`
  if [ "$file_overlap" == "" ]; then
    echo "[]ERROR: overlap file not exist ($file_overlap)!!"
    exit 1
  fi
  grep '^ ' $file_overlap | grep $master_date > ${path_expt}/input.lst.init
  grep '^ ' $file_overlap | grep -v $master_date |sort |tail -1 >> ${path_expt}/input.lst.init
  cat ${path_expt}/input.lst.init
  wc -l ${path_expt}/input.lst.init
else
  echo "[]input.lst.init file exist in $path_expt. Skipped."
fi


\rm -f $file_tmp
